<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Guide - Strigo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>

<body>
    <h1>Advanced Strigo Usage</h1>

    <h2>Dynamic Rate Limiting</h2>
    <p>Strigo allows you to apply dynamic rate limiting rules based on request characteristics. Here are some common
        scenarios:</p>

    <h3>1. Setting Limits Based on Query Parameters</h3>
    <pre><code>app.Get("/api/images", fiberMiddleware.RateLimitHandler(manager, func(c *fiber.Ctx) []limiter.RuleConfig {
    queryType := c.Query("type")
    if queryType == "image" {
        return []limiter.RuleConfig{
            {
                Pattern:  "image_daily",
                Strategy: config.TokenBucket,
                Period:   duration.DAILY,
                Limit:    3,
            },
        }
    }
    return []limiter.RuleConfig{
        {
            Pattern:  "default_daily",
            Strategy: config.TokenBucket,
            Period:   duration.DAILY,
            Limit:    100,
        },
    }
}), handler)</code></pre>

    <h3>2. Multiple Limits Based on User Type</h3>
    <pre><code>app.Get("/api/content", fiberMiddleware.RateLimitHandler(manager, func(c *fiber.Ctx) []limiter.RuleConfig {
    userType := c.Get("X-User-Type")

    switch userType {
    case "pro":
        return []limiter.RuleConfig{
            {
                Pattern:  "pro_minute",
                Strategy: config.TokenBucket,
                Period:   duration.MINUTELY,
                Limit:    100,
            },
            {
                Pattern:  "pro_daily",
                Strategy: config.TokenBucket,
                Period:   duration.DAILY,
                Limit:    10000,
            },
        }
    case "free":
        return []limiter.RuleConfig{
            {
                Pattern:  "free_minute",
                Strategy: config.TokenBucket,
                Period:   duration.MINUTELY,
                Limit:    10,
            },
            {
                Pattern:  "free_daily",
                Strategy: config.TokenBucket,
                Period:   duration.DAILY,
                Limit:    1000,
            },
        }
    default:
        return []limiter.RuleConfig{
            {
                Pattern:  "guest_minute",
                Strategy: config.TokenBucket,
                Period:   duration.MINUTELY,
                Limit:    5,
            },
        }
    }
}), handler)</code></pre>

    <h2>Using Memcached</h2>
    <p>Configuration to use Memcached instead of Redis:</p>
    <pre><code>manager := ratelimiter.NewManager(limiter.Memcached, "localhost:11211")</code></pre>

    <h2>Best Practices</h2>
    <ul>
        <li><strong>Pattern Naming:</strong> Use unique and meaningful pattern names for each endpoint</li>
        <li><strong>Multiple Limits:</strong> Define both short-term and long-term limits for critical endpoints</li>
        <li><strong>Error Handling:</strong> Handle rate limit exceeding with appropriate HTTP status codes</li>
        <li><strong>Monitoring:</strong> Log and monitor rate limit events</li>
    </ul>

    <h2>Performance Tips</h2>
    <ul>
        <li>Use Redis cluster for scalability under high load</li>
        <li>Optimize the number of patterns - avoid using too many patterns per request</li>
        <li>Configure appropriate buffer size and connection pool settings</li>
    </ul>

    <nav>
        <a href="index.html">Home</a> |
        <a href="getting-started.html">Getting Started Guide</a> |
        <a href="api.html">API Reference</a>
    </nav>
</body>

</html>